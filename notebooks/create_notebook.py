#!/usr/bin/env python3
"""
Script to create the WSI Registration Demo Jupyter notebook
"""

import json

def create_notebook():
    """Create the WSI Registration Demo notebook"""
    
    # The complete notebook structure
    notebook_content = {
        "cells": [
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "# WSI Registration Demo Notebook\n",
                    "\n",
                    "This notebook demonstrates the complete workflow for Whole Slide Image (WSI) registration using rigid and non-rigid techniques with nuclei-based analysis.\n",
                    "\n",
                    "## Overview\n",
                    "- **Rigid Registration**: Initial coarse alignment using traditional techniques\n",
                    "- **Nuclei Detection**: Extract nuclei from tissue patches\n",
                    "- **ICP Registration**: Point cloud-based fine alignment\n",
                    "- **Non-rigid Registration**: Coherent Point Drift (CPD) for local deformation\n",
                    "- **Interactive Visualization**: Bokeh plots for analysis\n",
                    "- **Evaluation**: Target Registration Error (TRE) metrics"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 1. Setup and Imports"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Enable inline plotting and auto-reload for development\n",
                    "%matplotlib inline\n",
                    "%load_ext autoreload\n",
                    "%autoreload 2\n",
                    "\n",
                    "# Import all necessary modules\n",
                    "from imports import *\n",
                    "from config import *\n",
                    "from preprocessing import *\n",
                    "from registration import *\n",
                    "from evaluation import *\n",
                    "from visualization import *\n",
                    "from nuclei_analysis import *\n",
                    "\n",
                    "# Setup Bokeh for notebook output\n",
                    "setup_bokeh_notebook()\n",
                    "\n",
                    "print(\"‚úÖ All modules imported successfully!\")\n",
                    "print(f\"Source WSI: {SOURCE_WSI_PATH}\")\n",
                    "print(f\"Target WSI: {TARGET_WSI_PATH}\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 2. Configuration Check\n",
                    "\n",
                    "Verify that all file paths are correct and files exist."
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "import os\n",
                    "\n",
                    "# Check if files exist\n",
                    "files_to_check = [\n",
                    "    SOURCE_WSI_PATH,\n",
                    "    TARGET_WSI_PATH,\n",
                    "    FIXED_POINTS_PATH,\n",
                    "    MOVING_POINTS_PATH\n",
                    "]\n",
                    "\n",
                    "print(\"File existence check:\")\n",
                    "for file_path in files_to_check:\n",
                    "    exists = os.path.exists(file_path)\n",
                    "    status = \"‚úÖ\" if exists else \"‚ùå\"\n",
                    "    print(f\"{status} {file_path}\")\n",
                    "\n",
                    "# Display current parameters\n",
                    "print(\"\\nCurrent Parameters:\")\n",
                    "print(f\"- Preprocessing Resolution: {PREPROCESSING_RESOLUTION}\")\n",
                    "print(f\"- Registration Resolution: {REGISTRATION_RESOLUTION}\")\n",
                    "print(f\"- Patch Size: {PATCH_SIZE}\")\n",
                    "print(f\"- Fixed Threshold: {FIXED_THRESHOLD}\")\n",
                    "print(f\"- Moving Threshold: {MOVING_THRESHOLD}\")\n",
                    "print(f\"- Min Nuclei Area: {MIN_NUCLEI_AREA}\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 3. Load and Preprocess WSI Images"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Load WSI images\n",
                    "print(\"Loading WSI images...\")\n",
                    "source_wsi, target_wsi, source, target = load_wsi_images(\n",
                    "    SOURCE_WSI_PATH, TARGET_WSI_PATH, PREPROCESSING_RESOLUTION\n",
                    ")\n",
                    "\n",
                    "print(f\"\\nLoaded images:\")\n",
                    "print(f\"Source shape: {source.shape}\")\n",
                    "print(f\"Target shape: {target.shape}\")"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Preprocess images\n",
                    "print(\"Preprocessing images...\")\n",
                    "source_prep, target_prep = preprocess_images(source, target)\n",
                    "\n",
                    "# Extract tissue masks\n",
                    "print(\"Extracting tissue masks...\")\n",
                    "source_mask, target_mask = extract_tissue_masks(source_prep, target_prep)\n",
                    "\n",
                    "print(\"‚úÖ Preprocessing completed!\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 4. Visualize Original Images"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Display original images side by side\n",
                    "fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n",
                    "\n",
                    "axes[0, 0].imshow(source_prep)\n",
                    "axes[0, 0].set_title('Source Image (Moving)')\n",
                    "axes[0, 0].axis('off')\n",
                    "\n",
                    "axes[0, 1].imshow(target_prep)\n",
                    "axes[0, 1].set_title('Target Image (Fixed)')\n",
                    "axes[0, 1].axis('off')\n",
                    "\n",
                    "axes[1, 0].imshow(source_mask, cmap='gray')\n",
                    "axes[1, 0].set_title('Source Tissue Mask')\n",
                    "axes[1, 0].axis('off')\n",
                    "\n",
                    "axes[1, 1].imshow(target_mask, cmap='gray')\n",
                    "axes[1, 1].set_title('Target Tissue Mask')\n",
                    "axes[1, 1].axis('off')\n",
                    "\n",
                    "plt.tight_layout()\n",
                    "plt.show()"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 5. Perform Rigid Registration"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Perform rigid registration\n",
                    "print(\"Performing rigid registration...\")\n",
                    "moving_img_transformed, final_transform = perform_rigid_registration(\n",
                    "    source_prep, target_prep, source_mask, target_mask\n",
                    ")\n",
                    "\n",
                    "print(\"\\nRigid transformation matrix:\")\n",
                    "print(final_transform)\n",
                    "\n",
                    "# Visualize transformed image\n",
                    "plt.figure(figsize=(12, 8))\n",
                    "plt.imshow(moving_img_transformed)\n",
                    "plt.title('Rigid Transformed Source Image')\n",
                    "plt.axis('off')\n",
                    "plt.show()\n",
                    "\n",
                    "print(\"‚úÖ Rigid registration completed!\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 6. Scale Transformation and Extract Patches"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Scale transformation for high resolution analysis\n",
                    "transform_40x = scale_transformation_matrix(\n",
                    "    final_transform, PREPROCESSING_RESOLUTION, REGISTRATION_RESOLUTION\n",
                    ")\n",
                    "\n",
                    "print(\"Scaled transformation matrix (40x):\")\n",
                    "print(transform_40x)\n",
                    "\n",
                    "# Extract patches from target WSI\n",
                    "print(\"\\nExtracting patches...\")\n",
                    "fixed_patch_extractor = extract_patches_from_wsi(\n",
                    "    target_wsi, target_mask, PATCH_SIZE, PATCH_STRIDE\n",
                    ")\n",
                    "\n",
                    "print(f\"Total patches extracted: {len(fixed_patch_extractor)}\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 7. Visualize Sample Patches"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Select a patch for visualization\n",
                    "patch_idx = 70  # You can change this index\n",
                    "loc = fixed_patch_extractor.coordinate_list[patch_idx]\n",
                    "location = (loc[0], loc[1])\n",
                    "\n",
                    "print(f\"Visualizing patch {patch_idx} at location {location}\")\n",
                    "\n",
                    "# Extract regions for comparison\n",
                    "fixed_tile = target_wsi.read_rect(location, VISUALIZATION_SIZE, resolution=40, units=\"power\")\n",
                    "moving_tile = source_wsi.read_rect(location, VISUALIZATION_SIZE, resolution=40, units=\"power\")\n",
                    "\n",
                    "# Create transformer and extract transformed tile\n",
                    "tfm = AffineWSITransformer(source_wsi, transform_40x)\n",
                    "transformed_tile = tfm.read_rect(location=location, size=VISUALIZATION_SIZE, resolution=0, units=\"level\")\n",
                    "\n",
                    "# Visualize patches\n",
                    "visualize_patches(fixed_tile, moving_tile, transformed_tile)"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 8. Evaluate Registration with Landmarks"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Load landmark points\n",
                    "print(\"Loading landmark points...\")\n",
                    "fixed_points, moving_points = load_landmark_points(FIXED_POINTS_PATH, MOVING_POINTS_PATH)\n",
                    "\n",
                    "print(f\"Fixed landmarks shape: {fixed_points.shape}\")\n",
                    "print(f\"Moving landmarks shape: {moving_points.shape}\")\n",
                    "\n",
                    "# Evaluate registration\n",
                    "eval_results = evaluate_registration_tre(\n",
                    "    fixed_points, moving_points, final_transform, target.shape, scale_factor=2\n",
                    ")\n",
                    "\n",
                    "print(f\"\\nüìä Registration Evaluation:\")\n",
                    "print(f\"- Initial TRE: {eval_results['tre_initial']:.2f} pixels\")\n",
                    "print(f\"- After Rigid TRE: {eval_results['tre_final']:.2f} pixels\")\n",
                    "print(f\"- Relative TRE: {eval_results['rtre_mean']:.4f}\")\n",
                    "print(f\"- rTRE Std: {eval_results['rtre_std']:.4f}\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 8.5. Validate Nuclei Detection on Sample Patch"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Test nuclei detection on a single patch to validate thresholds\n",
                    "print(\"Testing nuclei detection on sample patch...\")\n",
                    "print(\"This helps validate detection parameters before processing all patches.\")\n",
                    "\n",
                    "# Use the same patch we visualized earlier\n",
                    "test_patch_idx = patch_idx  # From section 7\n",
                    "print(f\"Testing on patch {test_patch_idx}\")\n",
                    "\n",
                    "# Get patch coordinates and images\n",
                    "test_coords = fixed_patch_extractor.coordinate_list[test_patch_idx]\n",
                    "test_location = (test_coords[0], test_coords[1])\n",
                    "test_size = (test_coords[2] - test_coords[0], test_coords[3] - test_coords[1])\n",
                    "\n",
                    "print(f\"Patch coordinates: {test_coords}\")\n",
                    "print(f\"Patch size: {test_size}\")"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Extract fixed patch and detect nuclei\n",
                    "print(\"Processing fixed image patch...\")\n",
                    "fixed_test_patch = fixed_patch_extractor[test_patch_idx]\n",
                    "\n",
                    "# Process nuclei in fixed patch\n",
                    "fixed_binary, fixed_stats, fixed_centroids = process_nuclei_patch(\n",
                    "    fixed_test_patch, FIXED_THRESHOLD, min_area=MIN_NUCLEI_AREA\n",
                    ")\n",
                    "\n",
                    "# Count valid nuclei (skip background at index 0)\n",
                    "fixed_nuclei_count = sum(1 for i in range(1, len(fixed_centroids)) \n",
                    "                        if fixed_stats[i, cv2.CC_STAT_AREA] > MIN_NUCLEI_AREA)\n",
                    "\n",
                    "print(f\"Fixed patch nuclei detection:\")\n",
                    "print(f\"- Total components found: {len(fixed_centroids)-1}\")\n",
                    "print(f\"- Valid nuclei (area > {MIN_NUCLEI_AREA}): {fixed_nuclei_count}\")\n",
                    "print(f\"- Threshold used: {FIXED_THRESHOLD}\")"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Extract moving patch and detect nuclei  \n",
                    "print(\"\\nProcessing moving image patch...\")\n",
                    "moving_test_patch = tfm.read_rect(test_location, test_size, resolution=40, units=\"power\")\n",
                    "\n",
                    "# Process nuclei in moving patch\n",
                    "moving_binary, moving_stats, moving_centroids = process_nuclei_patch(\n",
                    "    moving_test_patch, MOVING_THRESHOLD, gamma=GAMMA_CORRECTION, min_area=MIN_NUCLEI_AREA\n",
                    ")\n",
                    "\n",
                    "# Count valid nuclei\n",
                    "moving_nuclei_count = sum(1 for i in range(1, len(moving_centroids))\n",
                    "                         if moving_stats[i, cv2.CC_STAT_AREA] > MIN_NUCLEI_AREA)\n",
                    "\n",
                    "print(f\"Moving patch nuclei detection:\")\n",
                    "print(f\"- Total components found: {len(moving_centroids)-1}\")\n",
                    "print(f\"- Valid nuclei (area > {MIN_NUCLEI_AREA}): {moving_nuclei_count}\")\n",
                    "print(f\"- Threshold used: {MOVING_THRESHOLD}\")\n",
                    "print(f\"- Gamma correction: {GAMMA_CORRECTION}\")"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Visualize nuclei detection results\n",
                    "fig, axes = plt.subplots(3, 2, figsize=(16, 18))\n",
                    "\n",
                    "# Row 1: Original images\n",
                    "axes[0, 0].imshow(fixed_test_patch)\n",
                    "axes[0, 0].set_title(f'Fixed Patch (Original)\\\\nPatch {test_patch_idx}')\n",
                    "axes[0, 0].axis('off')\n",
                    "\n",
                    "axes[0, 1].imshow(moving_test_patch)\n",
                    "axes[0, 1].set_title(f'Moving Patch (Original)\\\\nPatch {test_patch_idx}')\n",
                    "axes[0, 1].axis('off')\n",
                    "\n",
                    "# Row 2: Binary masks\n",
                    "axes[1, 0].imshow(fixed_binary, cmap='gray')\n",
                    "axes[1, 0].set_title(f'Fixed Binary Mask\\\\nThreshold: {FIXED_THRESHOLD}')\n",
                    "axes[1, 0].axis('off')\n",
                    "\n",
                    "axes[1, 1].imshow(moving_binary, cmap='gray')\n",
                    "axes[1, 1].set_title(f'Moving Binary Mask\\\\nThreshold: {MOVING_THRESHOLD}, Gamma: {GAMMA_CORRECTION}')\n",
                    "axes[1, 1].axis('off')\n",
                    "\n",
                    "# Row 3: Detected nuclei overlays\n",
                    "axes[2, 0].imshow(fixed_test_patch)\n",
                    "# Plot valid nuclei centroids for fixed\n",
                    "for i in range(1, len(fixed_centroids)):\n",
                    "    if fixed_stats[i, cv2.CC_STAT_AREA] > MIN_NUCLEI_AREA:\n",
                    "        x, y = fixed_centroids[i]\n",
                    "        axes[2, 0].plot(x, y, 'r+', markersize=8, markeredgewidth=2)\n",
                    "        # Optional: add area as text\n",
                    "        area = fixed_stats[i, cv2.CC_STAT_AREA]\n",
                    "        axes[2, 0].text(x+5, y, f'{area}', fontsize=6, color='red')\n",
                    "axes[2, 0].set_title(f'Fixed Nuclei Detected\\\\nCount: {fixed_nuclei_count}')\n",
                    "axes[2, 0].axis('off')\n",
                    "\n",
                    "axes[2, 1].imshow(moving_test_patch)\n",
                    "# Plot valid nuclei centroids for moving\n",
                    "for i in range(1, len(moving_centroids)):\n",
                    "    if moving_stats[i, cv2.CC_STAT_AREA] > MIN_NUCLEI_AREA:\n",
                    "        x, y = moving_centroids[i]\n",
                    "        axes[2, 1].plot(x, y, 'b+', markersize=8, markeredgewidth=2)\n",
                    "        # Optional: add area as text\n",
                    "        area = moving_stats[i, cv2.CC_STAT_AREA]\n",
                    "        axes[2, 1].text(x+5, y, f'{area}', fontsize=6, color='blue')\n",
                    "axes[2, 1].set_title(f'Moving Nuclei Detected\\\\nCount: {moving_nuclei_count}')\n",
                    "axes[2, 1].axis('off')\n",
                    "\n",
                    "plt.tight_layout()\n",
                    "plt.show()"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Analyze nuclei detection statistics\n",
                    "print(\"\\nüìä Nuclei Detection Analysis:\")\n",
                    "\n",
                    "# Fixed image statistics\n",
                    "if fixed_nuclei_count > 0:\n",
                    "    fixed_areas = [fixed_stats[i, cv2.CC_STAT_AREA] for i in range(1, len(fixed_centroids))\n",
                    "                   if fixed_stats[i, cv2.CC_STAT_AREA] > MIN_NUCLEI_AREA]\n",
                    "    print(f\"\\nFixed Image:\")\n",
                    "    print(f\"- Nuclei count: {fixed_nuclei_count}\")\n",
                    "    print(f\"- Mean area: {np.mean(fixed_areas):.1f} pixels\")\n",
                    "    print(f\"- Area range: {np.min(fixed_areas):.0f} - {np.max(fixed_areas):.0f} pixels\")\n",
                    "    print(f\"- Area std: {np.std(fixed_areas):.1f} pixels\")\n",
                    "else:\n",
                    "    print(f\"\\nFixed Image: No nuclei detected!\")\n",
                    "    print(f\"‚ö†Ô∏è Consider lowering threshold (current: {FIXED_THRESHOLD})\")\n",
                    "\n",
                    "# Moving image statistics\n",
                    "if moving_nuclei_count > 0:\n",
                    "    moving_areas = [moving_stats[i, cv2.CC_STAT_AREA] for i in range(1, len(moving_centroids))\n",
                    "                    if moving_stats[i, cv2.CC_STAT_AREA] > MIN_NUCLEI_AREA]\n",
                    "    print(f\"\\nMoving Image:\")\n",
                    "    print(f\"- Nuclei count: {moving_nuclei_count}\")\n",
                    "    print(f\"- Mean area: {np.mean(moving_areas):.1f} pixels\")\n",
                    "    print(f\"- Area range: {np.min(moving_areas):.0f} - {np.max(moving_areas):.0f} pixels\")\n",
                    "    print(f\"- Area std: {np.std(moving_areas):.1f} pixels\")\n",
                    "else:\n",
                    "    print(f\"\\nMoving Image: No nuclei detected!\")\n",
                    "    print(f\"‚ö†Ô∏è Consider lowering threshold (current: {MOVING_THRESHOLD})\")\n",
                    "\n",
                    "# Recommendations\n",
                    "print(f\"\\nüí° Recommendations:\")\n",
                    "if fixed_nuclei_count == 0 or moving_nuclei_count == 0:\n",
                    "    print(\"‚ö†Ô∏è Low nuclei detection! Consider:\")\n",
                    "    print(\"   - Lowering thresholds in config.py\")\n",
                    "    print(\"   - Adjusting gamma correction\")\n",
                    "    print(\"   - Reducing MIN_NUCLEI_AREA\")\n",
                    "elif abs(fixed_nuclei_count - moving_nuclei_count) > max(fixed_nuclei_count, moving_nuclei_count) * 0.5:\n",
                    "    print(\"‚ö†Ô∏è Large difference in nuclei counts between images!\")\n",
                    "    print(\"   - Consider adjusting thresholds to balance detection\")\n",
                    "    print(\"   - Check if gamma correction is appropriate\")\n",
                    "else:\n",
                    "    print(\"‚úÖ Nuclei detection looks good!\")\n",
                    "    print(\"   - Reasonable nuclei counts in both images\")\n",
                    "    print(\"   - Ready to proceed with full pipeline\")\n",
                    "\n",
                    "print(f\"\\nüîß To adjust parameters, edit config.py:\")\n",
                    "print(f\"   - FIXED_THRESHOLD = {FIXED_THRESHOLD}\")\n",
                    "print(f\"   - MOVING_THRESHOLD = {MOVING_THRESHOLD}\")\n",
                    "print(f\"   - GAMMA_CORRECTION = {GAMMA_CORRECTION}\")\n",
                    "print(f\"   - MIN_NUCLEI_AREA = {MIN_NUCLEI_AREA}\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 9. Nuclei Detection and Analysis"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Process nuclei detection on all patches\n",
                    "print(\"Processing nuclei detection on all patches...\")\n",
                    "print(\"This may take several minutes depending on the number of patches...\")\n",
                    "print(\"\\nüí° Based on the validation above, the detection parameters look good!\")\n",
                    "\n",
                    "# Process a subset of patches for demonstration (adjust range as needed)\n",
                    "start_idx = 0\n",
                    "end_idx = min(50, len(fixed_patch_extractor) - 1)  # Process first 50 patches\n",
                    "\n",
                    "print(f\"Processing patches {start_idx} to {end_idx} ({end_idx-start_idx+1} patches)\")\n",
                    "print(\"For full analysis, set end_idx = len(fixed_patch_extractor) - 1\")\n",
                    "\n",
                    "all_fixed_nuclei_data, all_moving_nuclei_data = process_nuclei_in_patches(\n",
                    "    fixed_patch_extractor, tfm, start_idx, end_idx\n",
                    ")\n",
                    "\n",
                    "print(f\"\\nüî¨ Nuclei Detection Results:\")\n",
                    "print(f\"- Fixed nuclei detected: {len(all_fixed_nuclei_data)}\")\n",
                    "print(f\"- Moving nuclei detected: {len(all_moving_nuclei_data)}\")\n",
                    "print(f\"- Average nuclei per patch:\")\n",
                    "print(f\"  * Fixed: {len(all_fixed_nuclei_data)/(end_idx-start_idx+1):.1f}\")\n",
                    "print(f\"  * Moving: {len(all_moving_nuclei_data)/(end_idx-start_idx+1):.1f}\")\n",
                    "\n",
                    "# Save nuclei data\n",
                    "save_nuclei_data_to_csv(\n",
                    "    all_fixed_nuclei_data, all_moving_nuclei_data,\n",
                    "    FIXED_NUCLEI_CSV, MOVING_NUCLEI_CSV\n",
                    ")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 10. Interactive Nuclei Visualization"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Load nuclei coordinates\n",
                    "moving_df = load_nuclei_coordinates(MOVING_NUCLEI_CSV)\n",
                    "fixed_df = load_nuclei_coordinates(FIXED_NUCLEI_CSV)\n",
                    "\n",
                    "print(f\"Loaded nuclei data:\")\n",
                    "print(f\"- Fixed nuclei: {len(fixed_df)}\")\n",
                    "print(f\"- Moving nuclei: {len(moving_df)}\")\n",
                    "\n",
                    "# Create basic nuclei overlay plot\n",
                    "print(\"\\nCreating interactive nuclei overlay plot...\")\n",
                    "plot1 = create_nuclei_overlay_plot(moving_df, fixed_df, \n",
                    "                                  \"Original Nuclei Coordinates (Before Registration)\")\n",
                    "show_plot(plot1)"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Create detailed plot with color mapping by area\n",
                    "print(\"Creating detailed plot with color mapping...\")\n",
                    "plot2 = create_detailed_nuclei_plot_with_colormaps(moving_df, fixed_df)\n",
                    "show_plot(plot2)"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 11. ICP Registration on Nuclei Points"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Extract nuclei coordinates as point arrays\n",
                    "moving_points_nuclei = extract_nuclei_points(moving_df)\n",
                    "fixed_points_nuclei = extract_nuclei_points(fixed_df)\n",
                    "\n",
                    "print(f\"Nuclei points for ICP:\")\n",
                    "print(f\"- Moving points: {moving_points_nuclei.shape}\")\n",
                    "print(f\"- Fixed points: {fixed_points_nuclei.shape}\")\n",
                    "\n",
                    "# Perform ICP registration\n",
                    "print(\"\\nPerforming ICP registration on nuclei...\")\n",
                    "icp_transform, moving_rigid_transformed = perform_icp_registration(\n",
                    "    moving_points_nuclei, fixed_points_nuclei, RegistrationParams.ICP_THRESHOLD\n",
                    ")\n",
                    "\n",
                    "# Create DataFrame for rigid registered nuclei\n",
                    "moving_df_rigid = create_nuclei_dataframe_from_points(moving_rigid_transformed)\n",
                    "\n",
                    "print(\"‚úÖ ICP registration completed!\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 11.5. Shape-Aware Point Set Registration"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Perform shape-aware registration as an alternative to ICP\n",
                    "print(\"Performing Shape-Aware Point Set Registration...\")\n",
                    "print(\"This method considers both spatial coordinates and shape attributes (area).\")\n",
                    "\n",
                    "# Perform shape-aware registration\n",
                    "shape_registrator, shape_transform, shape_transformed_coords = perform_shape_aware_registration(\n",
                    "    fixed_df, moving_df,\n",
                    "    shape_attribute='area',\n",
                    "    shape_weight=0.3,  # 30% weight for shape, 70% for spatial distance\n",
                    "    max_iterations=200,\n",
                    "    tolerance=1e-8\n",
                    ")\n",
                    "\n",
                    "print(f\"\\nüìä Shape-Aware Registration Results:\")\n",
                    "print(f\"- Final error: {shape_registrator.final_error:.4f}\")\n",
                    "print(f\"- Translation: ({shape_registrator.translation[0]:.2f}, {shape_registrator.translation[1]:.2f})\")\n",
                    "print(f\"- Rotation: {np.degrees(shape_registrator.rotation):.2f} degrees\")\n",
                    "print(f\"- Scale: {shape_registrator.scale:.4f}\")\n",
                    "\n",
                    "print(f\"\\nShape-Aware Transformation Matrix:\")\n",
                    "print(shape_transform)\n",
                    "\n",
                    "# Create DataFrame for shape-aware registered nuclei\n",
                    "moving_df_shape_aware = create_nuclei_dataframe_from_points(shape_transformed_coords)\n",
                    "# Add registered coordinates to the original dataframe for visualization\n",
                    "moving_df_shape_aware = moving_df.copy()\n",
                    "moving_df_shape_aware['registered_x'] = shape_transformed_coords[:, 0]\n",
                    "moving_df_shape_aware['registered_y'] = shape_transformed_coords[:, 1]\n",
                    "\n",
                    "print(\"‚úÖ Shape-aware registration completed!\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 11.6. Compare Registration Methods"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Compare ICP vs Shape-Aware registration performance\n",
                    "print(\"Comparing ICP vs Shape-Aware Registration Methods...\")\n",
                    "\n",
                    "# Calculate TRE for both methods\n",
                    "# Sample subset of points for comparison\n",
                    "n_compare = min(1000, len(moving_points_nuclei), len(fixed_points_nuclei))\n",
                    "compare_indices = np.random.choice(len(moving_points_nuclei), n_compare, replace=False)\n",
                    "\n",
                    "fixed_compare = fixed_points_nuclei[compare_indices]\n",
                    "moving_compare = moving_points_nuclei[compare_indices]\n",
                    "icp_compare = moving_rigid_transformed[compare_indices]\n",
                    "shape_compare = shape_transformed_coords[compare_indices]\n",
                    "\n",
                    "# Calculate TRE for each method\n",
                    "tre_original = np.mean(np.linalg.norm(fixed_compare - moving_compare, axis=1))\n",
                    "tre_icp = np.mean(np.linalg.norm(fixed_compare - icp_compare, axis=1))\n",
                    "tre_shape_aware = np.mean(np.linalg.norm(fixed_compare - shape_compare, axis=1))\n",
                    "\n",
                    "print(f\"\\nüìà Registration Method Comparison (TRE on {n_compare} points):\")\n",
                    "print(f\"- Original (unregistered): {tre_original:.2f} pixels\")\n",
                    "print(f\"- ICP Registration: {tre_icp:.2f} pixels\")\n",
                    "print(f\"- Shape-Aware Registration: {tre_shape_aware:.2f} pixels\")\n",
                    "\n",
                    "# Calculate improvement percentages\n",
                    "icp_improvement = ((tre_original - tre_icp) / tre_original * 100)\n",
                    "shape_improvement = ((tre_original - tre_shape_aware) / tre_original * 100)\n",
                    "\n",
                    "print(f\"\\nüìä Improvement Analysis:\")\n",
                    "print(f\"- ICP improvement: {icp_improvement:.1f}%\")\n",
                    "print(f\"- Shape-Aware improvement: {shape_improvement:.1f}%\")\n",
                    "\n",
                    "if tre_shape_aware < tre_icp:\n",
                    "    relative_improvement = ((tre_icp - tre_shape_aware) / tre_icp * 100)\n",
                    "    print(f\"- Shape-Aware is {relative_improvement:.1f}% better than ICP\")\n",
                    "elif tre_icp < tre_shape_aware:\n",
                    "    relative_improvement = ((tre_shape_aware - tre_icp) / tre_shape_aware * 100)\n",
                    "    print(f\"- ICP is {relative_improvement:.1f}% better than Shape-Aware\")\n",
                    "else:\n",
                    "    print(f\"- Both methods perform similarly\")\n",
                    "\n",
                    "# Determine which method to use for subsequent steps\n",
                    "if tre_shape_aware < tre_icp:\n",
                    "    print(f\"\\n‚úÖ Using Shape-Aware registration for subsequent non-rigid steps\")\n",
                    "    moving_rigid_transformed = shape_transformed_coords\n",
                    "    icp_transform = shape_transform\n",
                    "    best_method = \"Shape-Aware\"\n",
                    "else:\n",
                    "    print(f\"\\n‚úÖ Using ICP registration for subsequent non-rigid steps\")\n",
                    "    best_method = \"ICP\"\n",
                    "\n",
                    "print(f\"Best method: {best_method}\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 11.7. Visualize Registration Method Comparison"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Create comparison visualization\n",
                    "print(\"Creating registration method comparison visualization...\")\n",
                    "\n",
                    "# Prepare data for comparison plot\n",
                    "icp_comparison_df = create_nuclei_dataframe_from_points(icp_compare)\n",
                    "icp_comparison_df['global_x'] = moving_compare[:, 0]\n",
                    "icp_comparison_df['global_y'] = moving_compare[:, 1]\n",
                    "icp_comparison_df['area'] = moving_df.iloc[compare_indices]['area'].values\n",
                    "\n",
                    "shape_comparison_df = moving_df.iloc[compare_indices].copy()\n",
                    "shape_comparison_df['registered_x'] = shape_compare[:, 0]\n",
                    "shape_comparison_df['registered_y'] = shape_compare[:, 1]\n",
                    "\n",
                    "fixed_comparison_df = pd.DataFrame({\n",
                    "    'global_x': fixed_compare[:, 0],\n",
                    "    'global_y': fixed_compare[:, 1],\n",
                    "    'area': fixed_df.iloc[compare_indices]['area'].values\n",
                    "})\n",
                    "\n",
                    "# Create method comparison plot\n",
                    "plot_comparison = create_method_comparison_plot(\n",
                    "    fixed_comparison_df, \n",
                    "    pd.DataFrame({\n",
                    "        'global_x': moving_compare[:, 0],\n",
                    "        'global_y': moving_compare[:, 1],\n",
                    "        'area': moving_df.iloc[compare_indices]['area'].values\n",
                    "    }),\n",
                    "    icp_comparison_df,\n",
                    "    shape_comparison_df\n",
                    ")\n",
                    "show_plot(plot_comparison)"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 11.8. Visualize Shape-Aware Registration Details"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Create detailed shape-aware registration visualization\n",
                    "print(\"Creating detailed shape-aware registration visualization...\")\n",
                    "\n",
                    "# Use the built-in visualization method of the shape-aware registrator\n",
                    "plot_shape_aware = visualize_shape_aware_registration(\n",
                    "    shape_registrator, \n",
                    "    title=f\"Shape-Aware Registration (Weight: {shape_registrator.shape_weight})\"\n",
                    ")\n",
                    "show_plot(plot_shape_aware)\n",
                    "\n",
                    "# Show parameter analysis\n",
                    "print(f\"\\nüîç Shape-Aware Registration Analysis:\")\n",
                    "print(f\"- Shape attribute used: {shape_registrator.shape_attribute}\")\n",
                    "print(f\"- Shape weight: {shape_registrator.shape_weight} (importance of shape vs spatial distance)\")\n",
                    "print(f\"- Spatial weight: {1 - shape_registrator.shape_weight}\")\n",
                    "print(f\"- Correspondences found: {len(shape_registrator.correspondence_indices)}\")\n",
                    "print(f\"- Optimization method: Powell with {shape_registrator.max_iterations} max iterations\")\n",
                    "\n",
                    "# Analyze shape attribute distribution\n",
                    "fixed_shape_stats = shape_registrator.fixed_points['area'].describe()\n",
                    "moving_shape_stats = shape_registrator.moving_points['area'].describe()\n",
                    "\n",
                    "print(f\"\\nüìä Shape Attribute (Area) Statistics:\")\n",
                    "print(f\"Fixed nuclei area - Mean: {fixed_shape_stats['mean']:.1f}, Std: {fixed_shape_stats['std']:.1f}\")\n",
                    "print(f\"Moving nuclei area - Mean: {moving_shape_stats['mean']:.1f}, Std: {moving_shape_stats['std']:.1f}\")\n",
                    "\n",
                    "# Suggest parameter tuning\n",
                    "print(f\"\\nüí° Parameter Tuning Suggestions:\")\n",
                    "if shape_registrator.final_error > 50:\n",
                    "    print(\"- Consider increasing shape_weight if nuclei areas are well-preserved between images\")\n",
                    "    print(\"- Consider decreasing shape_weight if there's significant area variation\")\n",
                    "else:\n",
                    "    print(\"- Current parameters seem well-tuned for this dataset\")\n",
                    "\n",
                    "if abs(fixed_shape_stats['mean'] - moving_shape_stats['mean']) > 50:\n",
                    "    print(\"- Large difference in mean areas detected - shape weight might need adjustment\")\n",
                    "else:\n",
                    "    print(\"- Area distributions are similar between datasets - good for shape-aware registration\")"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Find mutual nearest neighbors for robust correspondence\n",
                    "print(\"Finding mutual nearest neighbors...\")\n",
                    "fixed_mnn, moving_mnn, mnn_pairs = find_mutual_nearest_neighbors(\n",
                    "    fixed_points_nuclei, moving_rigid_transformed\n",
                    ")\n",
                    "\n",
                    "print(f\"MNN pairs found: {len(mnn_pairs)}\")\n",
                    "\n",
                    "# Perform CPD non-rigid registration\n",
                    "print(\"\\nPerforming CPD non-rigid registration...\")\n",
                    "print(\"This may take a few minutes...\")\n",
                    "\n",
                    "moving_nonrigid_transformed = perform_cpd_registration(\n",
                    "    moving_mnn, fixed_mnn,\n",
                    "    beta=RegistrationParams.CPD_BETA,\n",
                    "    alpha=RegistrationParams.CPD_ALPHA,\n",
                    "    max_iterations=RegistrationParams.CPD_MAX_ITERATIONS,\n",
                    "    tolerance=RegistrationParams.CPD_TOLERANCE\n",
                    ")\n",
                    "\n",
                    "print(\"‚úÖ CPD registration completed!\")\n",
                    "\n",
                    "# Calculate TRE improvement\n",
                    "tre_before = np.mean(np.linalg.norm(fixed_mnn - moving_mnn, axis=1))\n",
                    "tre_after = np.mean(np.linalg.norm(fixed_mnn - moving_nonrigid_transformed, axis=1))\n",
                    "\n",
                    "print(f\"\\nüìà CPD Registration Improvement:\")\n",
                    "print(f\"- TRE before CPD: {tre_before:.2f} pixels\")\n",
                    "print(f\"- TRE after CPD: {tre_after:.2f} pixels\")\n",
                    "print(f\"- Improvement: {((tre_before - tre_after) / tre_before * 100):.1f}%\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 13. Visualize Registration Comparison"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Create DataFrames for visualization\n",
                    "moving_df_nonrigid = create_nuclei_dataframe_from_points(moving_nonrigid_transformed)\n",
                    "fixed_df_mnn = create_nuclei_dataframe_from_points(fixed_mnn)\n",
                    "moving_df_mnn = create_nuclei_dataframe_from_points(moving_mnn)\n",
                    "\n",
                    "# Create comprehensive registration comparison plot\n",
                    "print(\"Creating comprehensive registration comparison plot...\")\n",
                    "print(f\"Including results from: Original ‚Üí ICP/Shape-Aware ‚Üí Non-rigid\")\n",
                    "\n",
                    "plot3 = create_registration_comparison_plot(\n",
                    "    fixed_df_mnn, moving_df_mnn, moving_df_mnn, moving_df_nonrigid\n",
                    ")\n",
                    "show_plot(plot3)\n",
                    "\n",
                    "# Show final comparison summary\n",
                    "print(f\"\\nüìä Complete Registration Pipeline Summary:\")\n",
                    "print(f\"- Method used for rigid registration: {best_method}\")\n",
                    "print(f\"- Mutual nearest neighbor pairs: {len(mnn_pairs)}\")\n",
                    "print(f\"- CPD non-rigid transformation applied\")\n",
                    "print(f\"- Visualization shows: Original (red) ‚Üí Rigid (green) ‚Üí Non-rigid (orange)\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 14. Generate Displacement Field"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Create displacement field for spatial transformation analysis\n",
                    "print(\"Creating displacement field...\")\n",
                    "\n",
                    "# Scale down coordinates for field generation\n",
                    "scale_factor = 64\n",
                    "source_points_scaled = moving_mnn / scale_factor\n",
                    "target_points_scaled = moving_nonrigid_transformed / scale_factor\n",
                    "\n",
                    "displacement_field = create_displacement_field(\n",
                    "    source_points_scaled, target_points_scaled,\n",
                    "    target.shape,\n",
                    "    method=RegistrationParams.INTERPOLATION_METHOD,\n",
                    "    sigma=RegistrationParams.DISPLACEMENT_SIGMA,\n",
                    "    max_displacement=RegistrationParams.MAX_DISPLACEMENT\n",
                    ")\n",
                    "\n",
                    "print(f\"Displacement field shape: {displacement_field.shape}\")\n",
                    "print(f\"Max displacement magnitude: {np.max(np.linalg.norm(displacement_field, axis=2)):.2f} pixels\")\n",
                    "\n",
                    "# Visualize displacement field magnitude\n",
                    "displacement_magnitude = np.linalg.norm(displacement_field, axis=2)\n",
                    "\n",
                    "plt.figure(figsize=(12, 8))\n",
                    "plt.imshow(displacement_magnitude, cmap='viridis')\n",
                    "plt.colorbar(label='Displacement Magnitude (pixels)')\n",
                    "plt.title('Non-Rigid Displacement Field Magnitude')\n",
                    "plt.axis('off')\n",
                    "plt.show()"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 14.1. Visualize Displacement Vectors"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Create a more detailed visualization of the displacement field\n",
                    "fig, axes = plt.subplots(1, 3, figsize=(18, 6))\n",
                    "\n",
                    "# Displacement in X direction\n",
                    "im1 = axes[0].imshow(displacement_field[:, :, 0], cmap='RdBu_r')\n",
                    "axes[0].set_title('X-Direction Displacement')\n",
                    "axes[0].axis('off')\n",
                    "plt.colorbar(im1, ax=axes[0], label='Pixels')\n",
                    "\n",
                    "# Displacement in Y direction\n",
                    "im2 = axes[1].imshow(displacement_field[:, :, 1], cmap='RdBu_r')\n",
                    "axes[1].set_title('Y-Direction Displacement')\n",
                    "axes[1].axis('off')\n",
                    "plt.colorbar(im2, ax=axes[1], label='Pixels')\n",
                    "\n",
                    "# Displacement magnitude\n",
                    "im3 = axes[2].imshow(displacement_magnitude, cmap='viridis')\n",
                    "axes[2].set_title('Displacement Magnitude')\n",
                    "axes[2].axis('off')\n",
                    "plt.colorbar(im3, ax=axes[2], label='Pixels')\n",
                    "\n",
                    "plt.tight_layout()\n",
                    "plt.show()\n",
                    "\n",
                    "# Show statistics\n",
                    "print(f\"\\nüìä Displacement Field Statistics:\")\n",
                    "print(f\"- Mean X displacement: {np.mean(displacement_field[:, :, 0]):.2f} pixels\")\n",
                    "print(f\"- Mean Y displacement: {np.mean(displacement_field[:, :, 1]):.2f} pixels\")\n",
                    "print(f\"- Mean magnitude: {np.mean(displacement_magnitude):.2f} pixels\")\n",
                    "print(f\"- Max magnitude: {np.max(displacement_magnitude):.2f} pixels\")\n",
                    "print(f\"- Std magnitude: {np.std(displacement_magnitude):.2f} pixels\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 14.2. Apply Displacement Field to Test Points"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Test the displacement field application on a subset of nuclei\n",
                    "print(\"Testing displacement field application...\")\n",
                    "\n",
                    "# Use a subset of moving nuclei for testing\n",
                    "test_moving_points = moving_points_nuclei[:100]  # First 100 nuclei\n",
                    "test_fixed_points = fixed_points_nuclei[:100]   # First 100 nuclei\n",
                    "\n",
                    "# Apply displacement field to test points\n",
                    "moved_points_test, valid_mask_test = apply_displacement_field_to_points(\n",
                    "    test_moving_points, displacement_field, pixel_scale=16\n",
                    ")\n",
                    "\n",
                    "print(f\"Test points processed: {len(test_moving_points)}\")\n",
                    "print(f\"Valid points after displacement: {np.sum(valid_mask_test)}\")\n",
                    "\n",
                    "# Calculate TRE improvement for test points\n",
                    "if np.sum(valid_mask_test) > 0:\n",
                    "    valid_fixed = test_fixed_points[valid_mask_test]\n",
                    "    valid_original = test_moving_points[valid_mask_test]\n",
                    "    \n",
                    "    tre_original_test = np.mean(np.linalg.norm(valid_fixed - valid_original, axis=1))\n",
                    "    tre_displaced_test = np.mean(np.linalg.norm(valid_fixed - moved_points_test, axis=1))\n",
                    "    \n",
                    "    improvement_test = ((tre_original_test - tre_displaced_test) / tre_original_test * 100)\n",
                    "    \n",
                    "    print(f\"\\nüéØ Test Point Results:\")\n",
                    "    print(f\"- Original TRE: {tre_original_test:.2f} pixels\")\n",
                    "    print(f\"- After displacement TRE: {tre_displaced_test:.2f} pixels\")\n",
                    "    print(f\"- Improvement: {improvement_test:.1f}%\")\n",
                    "else:\n",
                    "    print(\"‚ö†Ô∏è No valid points found after displacement field application\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 15. Final Evaluation with Test Landmarks"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Load evaluation landmarks (if available)\n",
                    "try:\n",
                    "    print(\"Loading evaluation landmarks...\")\n",
                    "    fixed_eval_points, moving_eval_points = load_evaluation_landmarks(\n",
                    "        EVAL_FIXED_POINTS_PATH, EVAL_MOVING_POINTS_PATH\n",
                    "    )\n",
                    "    \n",
                    "    print(f\"Evaluation landmarks loaded:\")\n",
                    "    print(f\"- Fixed: {fixed_eval_points.shape}\")\n",
                    "    print(f\"- Moving: {moving_eval_points.shape}\")\n",
                    "    \n",
                    "    # Convert ICP transform to 3x3 and scale\n",
                    "    transform_3x3 = convert_4x4_to_3x3_transform(icp_transform)\n",
                    "    scale_factor_eval = 10 / 40\n",
                    "    transform_3x3_scaled = transform_3x3.copy()\n",
                    "    transform_3x3_scaled[0:2, 2] = transform_3x3_scaled[0:2, 2] * scale_factor_eval\n",
                    "    \n",
                    "    print(f\"\\nScaled 3x3 transform matrix:\")\n",
                    "    print(transform_3x3_scaled)\n",
                    "    \n",
                    "    # Step 1: Apply rigid transformation to moving points\n",
                    "    print(\"\\nApplying rigid transformation to evaluation landmarks...\")\n",
                    "    rigid_eval_scale_factor = 10 / 0.625\n",
                    "    pre_transform_s = final_transform.copy()\n",
                    "    pre_transform_s[0:2, 2] = pre_transform_s[0:2, 2] * rigid_eval_scale_factor\n",
                    "    \n",
                    "    transformed_moving_points = transform_points_homogeneous(moving_eval_points, pre_transform_s)\n",
                    "    \n",
                    "    # Step 2: Apply ICP correction\n",
                    "    print(\"Applying ICP correction...\")\n",
                    "    transformed_moving_points1 = transform_points_homogeneous(\n",
                    "        transformed_moving_points, np.linalg.inv(transform_3x3_scaled)\n",
                    "    )\n",
                    "    \n",
                    "    # Step 3: Apply displacement field\n",
                    "    print(\"Applying displacement field to evaluation landmarks...\")\n",
                    "    moved_points_final, valid_mask_eval = apply_displacement_field_to_points(\n",
                    "        transformed_moving_points1, displacement_field, pixel_scale=16\n",
                    "    )\n",
                    "    \n",
                    "    # Calculate TRE at each step\n",
                    "    tre_init_eval = np.mean(np.linalg.norm(fixed_eval_points - moving_eval_points, axis=1))\n",
                    "    tre_rigid_eval = np.mean(np.linalg.norm(fixed_eval_points - transformed_moving_points, axis=1))\n",
                    "    tre_icp_eval = np.mean(np.linalg.norm(fixed_eval_points - transformed_moving_points1, axis=1))\n",
                    "    \n",
                    "    if np.sum(valid_mask_eval) > 0:\n",
                    "        fixed_eval_valid = fixed_eval_points[valid_mask_eval]\n",
                    "        tre_nonrigid_eval = np.mean(np.linalg.norm(fixed_eval_valid - moved_points_final, axis=1))\n",
                    "    else:\n",
                    "        tre_nonrigid_eval = float('inf')\n",
                    "        print(\"‚ö†Ô∏è No valid points after displacement field application\")\n",
                    "    \n",
                    "    print(f\"\\nüéØ Complete Evaluation Results:\")\n",
                    "    print(f\"- Initial TRE: {tre_init_eval:.2f} pixels\")\n",
                    "    print(f\"- After Rigid TRE: {tre_rigid_eval:.2f} pixels\")\n",
                    "    print(f\"- After ICP TRE: {tre_icp_eval:.2f} pixels\")\n",
                    "    print(f\"- After Non-rigid TRE: {tre_nonrigid_eval:.2f} pixels\")\n",
                    "    print(f\"- Valid points: {np.sum(valid_mask_eval)}/{len(valid_mask_eval)}\")\n",
                    "    \n",
                    "    # Calculate improvement percentages\n",
                    "    if tre_nonrigid_eval != float('inf'):\n",
                    "        rigid_improvement = ((tre_init_eval - tre_rigid_eval) / tre_init_eval * 100)\n",
                    "        icp_improvement = ((tre_rigid_eval - tre_icp_eval) / tre_rigid_eval * 100)\n",
                    "        nonrigid_improvement = ((tre_icp_eval - tre_nonrigid_eval) / tre_icp_eval * 100)\n",
                    "        total_improvement = ((tre_init_eval - tre_nonrigid_eval) / tre_init_eval * 100)\n",
                    "        \n",
                    "        print(f\"\\nüìä Step-by-Step Improvement Analysis:\")\n",
                    "        print(f\"- Rigid registration improvement: {rigid_improvement:.1f}%\")\n",
                    "        print(f\"- ICP registration improvement: {icp_improvement:.1f}%\")\n",
                    "        print(f\"- Non-rigid registration improvement: {nonrigid_improvement:.1f}%\")\n",
                    "        print(f\"- Total improvement: {total_improvement:.1f}%\")\n",
                    "    \n",
                    "except Exception as e:\n",
                    "    print(f\"‚ö†Ô∏è Could not load evaluation landmarks: {e}\")\n",
                    "    print(\"Skipping final evaluation step.\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 15.1. Visualize Complete Transformation Pipeline"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Create a comprehensive visualization of the transformation pipeline\n",
                    "if 'fixed_eval_points' in locals() and 'moving_eval_points' in locals():\n",
                    "    print(\"Creating transformation pipeline visualization...\")\n",
                    "    \n",
                    "    # Sample a subset of points for cleaner visualization\n",
                    "    n_vis_points = min(20, len(fixed_eval_points))\n",
                    "    vis_indices = np.random.choice(len(fixed_eval_points), n_vis_points, replace=False)\n",
                    "    \n",
                    "    fixed_vis = fixed_eval_points[vis_indices]\n",
                    "    moving_vis = moving_eval_points[vis_indices]\n",
                    "    \n",
                    "    # Apply transformations step by step\n",
                    "    moving_rigid_vis = transform_points_homogeneous(moving_vis, pre_transform_s)\n",
                    "    moving_icp_vis = transform_points_homogeneous(moving_rigid_vis, np.linalg.inv(transform_3x3_scaled))\n",
                    "    \n",
                    "    # Apply displacement field to visualization points\n",
                    "    moving_nonrigid_vis, valid_vis_mask = apply_displacement_field_to_points(\n",
                    "        moving_icp_vis, displacement_field, pixel_scale=16\n",
                    "    )\n",
                    "    \n",
                    "    # Create the visualization\n",
                    "    fig, axes = plt.subplots(2, 2, figsize=(16, 12))\n",
                    "    \n",
                    "    # Plot 1: Original alignment\n",
                    "    axes[0, 0].scatter(fixed_vis[:, 0], fixed_vis[:, 1], c='blue', s=100, alpha=0.7, label='Fixed', marker='s')\n",
                    "    axes[0, 0].scatter(moving_vis[:, 0], moving_vis[:, 1], c='red', s=100, alpha=0.7, label='Moving (Original)', marker='o')\n",
                    "    # Draw lines connecting corresponding points\n",
                    "    for i in range(len(fixed_vis)):\n",
                    "        axes[0, 0].plot([fixed_vis[i, 0], moving_vis[i, 0]], [fixed_vis[i, 1], moving_vis[i, 1]], 'k--', alpha=0.3)\n",
                    "    axes[0, 0].set_title('Step 1: Original Alignment')\n",
                    "    axes[0, 0].legend()\n",
                    "    axes[0, 0].grid(True, alpha=0.3)\n",
                    "    axes[0, 0].set_aspect('equal')\n",
                    "    \n",
                    "    # Plot 2: After rigid registration\n",
                    "    axes[0, 1].scatter(fixed_vis[:, 0], fixed_vis[:, 1], c='blue', s=100, alpha=0.7, label='Fixed', marker='s')\n",
                    "    axes[0, 1].scatter(moving_rigid_vis[:, 0], moving_rigid_vis[:, 1], c='green', s=100, alpha=0.7, label='Moving (Rigid)', marker='^')\n",
                    "    # Draw lines connecting corresponding points\n",
                    "    for i in range(len(fixed_vis)):\n",
                    "        axes[0, 1].plot([fixed_vis[i, 0], moving_rigid_vis[i, 0]], [fixed_vis[i, 1], moving_rigid_vis[i, 1]], 'k--', alpha=0.3)\n",
                    "    axes[0, 1].set_title('Step 2: After Rigid Registration')\n",
                    "    axes[0, 1].legend()\n",
                    "    axes[0, 1].grid(True, alpha=0.3)\n",
                    "    axes[0, 1].set_aspect('equal')\n",
                    "    \n",
                    "    # Plot 3: After ICP registration\n",
                    "    axes[1, 0].scatter(fixed_vis[:, 0], fixed_vis[:, 1], c='blue', s=100, alpha=0.7, label='Fixed', marker='s')\n",
                    "    axes[1, 0].scatter(moving_icp_vis[:, 0], moving_icp_vis[:, 1], c='orange', s=100, alpha=0.7, label='Moving (ICP)', marker='d')\n",
                    "    # Draw lines connecting corresponding points\n",
                    "    for i in range(len(fixed_vis)):\n",
                    "        axes[1, 0].plot([fixed_vis[i, 0], moving_icp_vis[i, 0]], [fixed_vis[i, 1], moving_icp_vis[i, 1]], 'k--', alpha=0.3)\n",
                    "    axes[1, 0].set_title('Step 3: After ICP Registration')\n",
                    "    axes[1, 0].legend()\n",
                    "    axes[1, 0].grid(True, alpha=0.3)\n",
                    "    axes[1, 0].set_aspect('equal')\n",
                    "    \n",
                    "    # Plot 4: After non-rigid registration\n",
                    "    axes[1, 1].scatter(fixed_vis[:, 0], fixed_vis[:, 1], c='blue', s=100, alpha=0.7, label='Fixed', marker='s')\n",
                    "    if np.sum(valid_vis_mask) > 0:\n",
                    "        valid_fixed_vis = fixed_vis[valid_vis_mask]\n",
                    "        axes[1, 1].scatter(moving_nonrigid_vis[:, 0], moving_nonrigid_vis[:, 1], c='purple', s=100, alpha=0.7, label='Moving (Non-rigid)', marker='*')\n",
                    "        # Draw lines connecting corresponding points (only valid ones)\n",
                    "        for i, valid in enumerate(valid_vis_mask):\n",
                    "            if valid:\n",
                    "                valid_idx = np.sum(valid_vis_mask[:i+1]) - 1\n",
                    "                axes[1, 1].plot([fixed_vis[i, 0], moving_nonrigid_vis[valid_idx, 0]], \n",
                    "                               [fixed_vis[i, 1], moving_nonrigid_vis[valid_idx, 1]], 'k--', alpha=0.3)\n",
                    "    else:\n",
                    "        axes[1, 1].text(0.5, 0.5, 'No valid points\\\\nafter displacement', \n",
                    "                       transform=axes[1, 1].transAxes, ha='center', va='center', fontsize=12)\n",
                    "    axes[1, 1].set_title('Step 4: After Non-Rigid Registration')\n",
                    "    axes[1, 1].legend()\n",
                    "    axes[1, 1].grid(True, alpha=0.3)\n",
                    "    axes[1, 1].set_aspect('equal')\n",
                    "    \n",
                    "    plt.tight_layout()\n",
                    "    plt.show()\n",
                    "    \n",
                    "    # Calculate and display TRE for visualization points\n",
                    "    tre_vis_original = np.mean(np.linalg.norm(fixed_vis - moving_vis, axis=1))\n",
                    "    tre_vis_rigid = np.mean(np.linalg.norm(fixed_vis - moving_rigid_vis, axis=1))\n",
                    "    tre_vis_icp = np.mean(np.linalg.norm(fixed_vis - moving_icp_vis, axis=1))\n",
                    "    \n",
                    "    if np.sum(valid_vis_mask) > 0:\n",
                    "        valid_fixed_vis = fixed_vis[valid_vis_mask]\n",
                    "        tre_vis_nonrigid = np.mean(np.linalg.norm(valid_fixed_vis - moving_nonrigid_vis, axis=1))\n",
                    "    else:\n",
                    "        tre_vis_nonrigid = float('inf')\n",
                    "    \n",
                    "    print(f\"\\nüìà Visualization Points TRE:\")\n",
                    "    print(f\"- Original: {tre_vis_original:.2f} pixels\")\n",
                    "    print(f\"- After Rigid: {tre_vis_rigid:.2f} pixels\")\n",
                    "    print(f\"- After ICP: {tre_vis_icp:.2f} pixels\")\n",
                    "    print(f\"- After Non-rigid: {tre_vis_nonrigid:.2f} pixels\")\n",
                    "    \n",
                    "else:\n",
                    "    print(\"‚ö†Ô∏è Evaluation landmarks not available for transformation visualization\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 16. Summary and Results"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Create a summary of the registration workflow\n",
                    "print(\"üéâ WSI Registration Workflow Completed!\")\n",
                    "print(\"=\" * 50)\n",
                    "\n",
                    "print(f\"\\nüìÅ Input Data:\")\n",
                    "print(f\"- Source WSI: {os.path.basename(SOURCE_WSI_PATH)}\")\n",
                    "print(f\"- Target WSI: {os.path.basename(TARGET_WSI_PATH)}\")\n",
                    "print(f\"- Image dimensions: {source.shape} ‚Üí {target.shape}\")\n",
                    "\n",
                    "print(f\"\\nüî¨ Nuclei Analysis:\")\n",
                    "print(f\"- Fixed nuclei detected: {len(all_fixed_nuclei_data):,}\")\n",
                    "print(f\"- Moving nuclei detected: {len(all_moving_nuclei_data):,}\")\n",
                    "print(f\"- Mutual nearest neighbors: {len(mnn_pairs):,}\")\n",
                    "\n",
                    "print(f\"\\nüìä Registration Performance:\")\n",
                    "print(f\"- Initial TRE: {eval_results['tre_initial']:.2f} pixels\")\n",
                    "print(f\"- Post-rigid TRE: {eval_results['tre_final']:.2f} pixels\")\n",
                    "print(f\"- Relative TRE: {eval_results['rtre_mean']:.4f}\")\n",
                    "\n",
                    "# Add registration method comparison\n",
                    "if 'best_method' in locals():\n",
                    "    print(f\"\\nüéØ Registration Method Comparison:\")\n",
                    "    print(f\"- Best rigid method: {best_method}\")\n",
                    "    if 'tre_icp' in locals() and 'tre_shape_aware' in locals():\n",
                    "        print(f\"- ICP TRE: {tre_icp:.2f} pixels\")\n",
                    "        print(f\"- Shape-Aware TRE: {tre_shape_aware:.2f} pixels\")\n",
                    "        print(f\"- Shape-Aware used weight: {shape_registrator.shape_weight} for area\")\n",
                    "\n",
                    "# Add displacement field summary if available\n",
                    "if 'displacement_field' in locals():\n",
                    "    displacement_stats = np.linalg.norm(displacement_field, axis=2)\n",
                    "    print(f\"\\nüåä Displacement Field:\")\n",
                    "    print(f\"- Field shape: {displacement_field.shape}\")\n",
                    "    print(f\"- Mean displacement: {np.mean(displacement_stats):.2f} pixels\")\n",
                    "    print(f\"- Max displacement: {np.max(displacement_stats):.2f} pixels\")\n",
                    "    print(f\"- Std displacement: {np.std(displacement_stats):.2f} pixels\")\n",
                    "\n",
                    "# Add final evaluation summary if available\n",
                    "if 'tre_init_eval' in locals():\n",
                    "    print(f\"\\nüéØ Final Evaluation (Test Landmarks):\")\n",
                    "    print(f\"- Initial TRE: {tre_init_eval:.2f} pixels\")\n",
                    "    print(f\"- Final TRE: {tre_nonrigid_eval:.2f} pixels\")\n",
                    "    if tre_nonrigid_eval != float('inf'):\n",
                    "        total_improvement_final = ((tre_init_eval - tre_nonrigid_eval) / tre_init_eval * 100)\n",
                    "        print(f\"- Total improvement: {total_improvement_final:.1f}%\")\n",
                    "\n",
                    "print(f\"\\nüíæ Output Files:\")\n",
                    "print(f\"- Fixed nuclei: {FIXED_NUCLEI_CSV}\")\n",
                    "print(f\"- Moving nuclei: {MOVING_NUCLEI_CSV}\")\n",
                    "print(f\"- Interactive plots generated above\")\n",
                    "\n",
                    "print(f\"\\nüõ†Ô∏è Next Steps:\")\n",
                    "print(\"- Adjust parameters in config.py for better results\")\n",
                    "print(\"- Process more patches for comprehensive analysis\")\n",
                    "print(\"- Export displacement field for downstream applications\")\n",
                    "print(\"- Apply registration to full-resolution images\")\n",
                    "print(\"- Use displacement field for transforming additional data\")\n",
                    "print(\"- Experiment with different shape weights in shape-aware registration\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## 17. Optional: Export Results"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Optional: Save transformation matrices and displacement field\n",
                    "import pickle\n",
                    "from datetime import datetime\n",
                    "\n",
                    "# Create timestamp for unique filenames\n",
                    "timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n",
                    "\n",
                    "# Save transformation matrices and displacement field\n",
                    "transforms = {\n",
                    "    'rigid_transform': final_transform,\n",
                    "    'rigid_transform_40x': transform_40x,\n",
                    "    'icp_transform': icp_transform,\n",
                    "    'displacement_field': displacement_field,\n",
                    "    'cpd_source_points': moving_mnn,\n",
                    "    'cpd_target_points': moving_nonrigid_transformed,\n",
                    "    'target_image_shape': target.shape\n",
                    "}\n",
                    "\n",
                    "transform_filename = f'wsi_registration_transforms_{timestamp}.pkl'\n",
                    "with open(transform_filename, 'wb') as f:\n",
                    "    pickle.dump(transforms, f)\n",
                    "\n",
                    "print(f\"‚úÖ Transformation matrices saved to: {transform_filename}\")\n",
                    "\n",
                    "# Save nuclei coordinates with transformation info\n",
                    "nuclei_data = {\n",
                    "    'fixed_nuclei': all_fixed_nuclei_data,\n",
                    "    'moving_nuclei': all_moving_nuclei_data,\n",
                    "    'moving_rigid_transformed': moving_rigid_transformed,\n",
                    "    'moving_mnn': moving_mnn,\n",
                    "    'fixed_mnn': fixed_mnn,\n",
                    "    'moving_nonrigid_transformed': moving_nonrigid_transformed\n",
                    "}\n",
                    "\n",
                    "nuclei_filename = f'wsi_nuclei_data_{timestamp}.pkl'\n",
                    "with open(nuclei_filename, 'wb') as f:\n",
                    "    pickle.dump(nuclei_data, f)\n",
                    "\n",
                    "print(f\"‚úÖ Nuclei data saved to: {nuclei_filename}\")\n",
                    "\n",
                    "# Save comprehensive summary report\n",
                    "report_filename = f'wsi_registration_report_{timestamp}.txt'\n",
                    "with open(report_filename, 'w') as f:\n",
                    "    f.write(f\"WSI Registration Comprehensive Report\\n\")\n",
                    "    f.write(f\"Generated: {datetime.now()}\\n\")\n",
                    "    f.write(f\"=\" * 50 + \"\\n\\n\")\n",
                    "    \n",
                    "    f.write(f\"INPUT DATA:\\n\")\n",
                    "    f.write(f\"Source WSI: {SOURCE_WSI_PATH}\\n\")\n",
                    "    f.write(f\"Target WSI: {TARGET_WSI_PATH}\\n\")\n",
                    "    f.write(f\"Image shapes: {source.shape} ‚Üí {target.shape}\\n\\n\")\n",
                    "    \n",
                    "    f.write(f\"REGISTRATION RESULTS:\\n\")\n",
                    "    f.write(f\"Initial TRE: {eval_results['tre_initial']:.2f} pixels\\n\")\n",
                    "    f.write(f\"Post-rigid TRE: {eval_results['tre_final']:.2f} pixels\\n\")\n",
                    "    f.write(f\"Relative TRE: {eval_results['rtre_mean']:.4f}\\n\\n\")\n",
                    "    \n",
                    "    f.write(f\"NUCLEI ANALYSIS:\\n\")\n",
                    "    f.write(f\"Fixed nuclei detected: {len(all_fixed_nuclei_data)}\\n\")\n",
                    "    f.write(f\"Moving nuclei detected: {len(all_moving_nuclei_data)}\\n\")\n",
                    "    f.write(f\"MNN pairs: {len(mnn_pairs)}\\n\\n\")\n",
                    "    \n",
                    "    if 'displacement_field' in locals():\n",
                    "        displacement_stats = np.linalg.norm(displacement_field, axis=2)\n",
                    "        f.write(f\"DISPLACEMENT FIELD:\\n\")\n",
                    "        f.write(f\"Field shape: {displacement_field.shape}\\n\")\n",
                    "        f.write(f\"Mean displacement: {np.mean(displacement_stats):.2f} pixels\\n\")\n",
                    "        f.write(f\"Max displacement: {np.max(displacement_stats):.2f} pixels\\n\")\n",
                    "        f.write(f\"Std displacement: {np.std(displacement_stats):.2f} pixels\\n\\n\")\n",
                    "    \n",
                    "    if 'tre_init_eval' in locals():\n",
                    "        f.write(f\"FINAL EVALUATION:\\n\")\n",
                    "        f.write(f\"Initial TRE: {tre_init_eval:.2f} pixels\\n\")\n",
                    "        f.write(f\"Final TRE: {tre_nonrigid_eval:.2f} pixels\\n\")\n",
                    "        if tre_nonrigid_eval != float('inf'):\n",
                    "            total_improvement_final = ((tre_init_eval - tre_nonrigid_eval) / tre_init_eval * 100)\n",
                    "            f.write(f\"Total improvement: {total_improvement_final:.1f}%\\n\")\n",
                    "    \n",
                    "    f.write(f\"\\nOUTPUT FILES:\\n\")\n",
                    "    f.write(f\"Transformations: {transform_filename}\\n\")\n",
                    "    f.write(f\"Nuclei data: {nuclei_filename}\\n\")\n",
                    "    f.write(f\"Fixed nuclei CSV: {FIXED_NUCLEI_CSV}\\n\")\n",
                    "    f.write(f\"Moving nuclei CSV: {MOVING_NUCLEI_CSV}\\n\")\n",
                    "\n",
                    "print(f\"‚úÖ Comprehensive report saved to: {report_filename}\")\n",
                    "\n",
                    "print(f\"\\nüéä Analysis complete! All results have been saved.\")\n",
                    "print(f\"\\nüì¶ Generated Files:\")\n",
                    "print(f\"- {transform_filename}\")\n",
                    "print(f\"- {nuclei_filename}\")\n",
                    "print(f\"- {report_filename}\")"
                ]
            }
        ],
        "metadata": {
            "kernelspec": {
                "display_name": "Python 3",
                "language": "python",
                "name": "python3"
            },
            "language_info": {
                "codemirror_mode": {
                    "name": "ipython",
                    "version": 3
                },
                "file_extension": ".py",
                "mimetype": "text/x-python",
                "name": "python",
                "nbconvert_exporter": "python",
                "pygments_lexer": "ipython3",
                "version": "3.8.5"
            }
        },
        "nbformat": 4,
        "nbformat_minor": 4
    }
    
    # Write the notebook content to file
    with open('WSI_Registration_Demo.ipynb', 'w') as f:
        json.dump(notebook_content, f, indent=2)
    
    print("‚úÖ Notebook created successfully: WSI_Registration_Demo.ipynb")
    print("\nTo open the notebook:")
    print("1. Navigate to the directory containing the notebook")
    print("2. Run: jupyter notebook WSI_Registration_Demo.ipynb")
    print("3. Or run: jupyter lab WSI_Registration_Demo.ipynb")

if __name__ == "__main__":
    create_notebook()